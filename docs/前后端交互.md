# 前后端交互接口

## 用户模块接口

### 首页

- 请求地址：/user/index
- 请求方式：get
- 返回响应：login.html

### 登录接口

- 请求地址：/user/login

- 请求方式：post

- 请求参数：  

  | 请求字段 | 字段含义   | 是否必填 |
  | -------- | ---------- | -------- |
  | mobile   | 用户手机号 | 必填     |
  | password | 密码       | 必填     |

## 商品模块接口

### 商品列表接口

- 请求地址：/goods/goodsList
- 请求方式：get
- 返回响应：goods_list.htm

#### 工作流程

1. 客户端发出获取商品列表信息的异步请求；
2. 服务端从Redis中获取商品列表`goods_list.htm`，如果存在，则直接返回给客户端，如果不存在，则进入3；
3. 服务端从商品模块中查询商品列表信息，然后使用`ThymeleafViewResolver`渲染引擎手动渲染商品列表页面，将渲染后的页面数据存储缓存在Redis中，并返回商品列表页面给客户端。

#### 总结

上述工作流程对`/goods/goodsList`接口实现了页面级缓存；从Redis中获取页面，如果没有则需要手动渲染页面，并且将渲染的页面存储在Redis中供下一次访问时获取。通过引入缓存，避免每次从数据库中获取数据后使用模板渲染html文件，从而省去服务器程序的渲染html文件的不必要工作和的减轻数据库的访问压力。

### 商品详情接口

- 请求地址：/goods/getDetails/{goodsId}

- 请求方式：get

- 请求参数：  

  | 请求字段 | 字段含义 | 是否必填 |
  | -------- | -------- | -------- |
  | goodsId  | 商品id   | 必填     |

- 返回响应：  

  ```java
  {
      "code": 0,
      "msg": "success",
      "data": {
          "bargainsStatus": 1,
          "remainSeconds": 0,
          "goods": {
              "id": 1,
              "goodsName": "iphoneX",
              "goodsTitle": "Apple iPhone X (A1865) 64GB 银色 移动联通电信4G手机",
              "goodsImg": "/img/iphonex.png",
              "goodsDetail": "Apple iPhone X (A1865) 64GB 银色 移动联通电信4G手机",
              "goodsPrice": 8765,
              "goodsStock": 10000,
              "bargainsPrice": 0.01,
              "stockCount": 9,
              "startDate": "2020-05-01T13:51:23.000+0000",
              "endDate": "2020-05-03T13:51:27.000+0000"
          },
          "user": {
              "uuid": 3,
              "phone": 32435252621,
              "nickname": "海之言",
              "password": "b7797cce01b4b131b433b6acf4add449",
              "salt": "1a2b3c4d",
              "head": null,
              "registerDate": 2020-04-10 20:16:01,
              "lastLoginDate": null,
              "loginCount": 0
          }
      }
  }
  ```

#### 工作流程

1. 客户端发出获取商品详情信息的请求；
2. 服务端通过商品id从商品模块中读取商品详细信息，计算秒杀状态，将秒杀状态和剩余时间以及商品详细信息一并返回给客户端。

## 秒杀模块接口

### 获取验证码接口

- 接口地址：/bargains/verifyCode?goodsId={}

- 请求方式：get

- 请求参数：  

  | 请求字段 | 字段含义 | 是否必填 |
  | -------- | -------- | -------- |
  | goodsId  | 商品id   | 必填     |

- 返回响应：验证码图片

#### 工作流程

客户端发出获取验证请求，服务端生成验证码图片，并通过response对象返回，将验证码结果存储于Redis中。

### 获取随机秒杀地址接口

- 接口地址：/bargains/path?goodsId={}&verifyCode={}

- 请求方式：get

- 请求参数：  

  | 请求字段   | 字段含义   | 是否必填 |
  | ---------- | ---------- | -------- |
  | goodsId    | 商品id     | 必填     |
  | verifyCode | 验证码结果 | 必填     |

- 返回响应：随机秒杀地址

#### 工作流程

1. 客户端获取验证码结果，并将商品id和验证码结果作为请求参数传递到服务端；
2. 服务端获取用户id和商品id，从Redis中查询该用户和该商品下的验证码结果；
3. 比较客户端传递到服务端的验证码结果和Redis中查询出来的验证码结果，如果校验失败，返回非法请求，通过则进入4；
4. 创建随机秒杀地址（MD5随机字符串），并将其存储在Redis中，其key为用户id和商品id的组合，已确定秒杀地址的唯一性。

### 秒杀接口

- 接口地址：/bargains/{path}/doBargains

- 请求方式：post

- 请求参数：  

  | 请求字段 | 字段含义     | 是否必填 |
  | -------- | ------------ | -------- |
  | path     | 随机秒杀地址 | 必填     |
  | goodsId  | 商品id       | 必填     |

返回响应：秒杀状态

#### 工作流程

1. 以用户id和商品id的组合为键从Redis中读取随机地址，如果随机地址和客户端传入的随机地址不一致，则返回非法请求，如果一致，则进入2；
2. 通过内存标记，判断商品是否已秒杀结束，如果已秒杀结束，则返回秒杀结束标志；
3. 如果判断为秒杀商品未结束则从Redis中预减库存，并在内存中标记商品是否秒杀结束；
4. 从Redis中读取秒杀订单信息，判断是否重复秒杀，如果重复秒杀，则返回重复秒杀提示，如果是第一次秒杀，则进入5；
5. 第4步中可能存在缓存数据已经无效的情形，所以，需要从数据库中读取秒杀订单信息，如果存在订单记录，则返回重复秒杀提示，如果没有，则进入6；
6. 将秒杀请求发送到消息队列中，返回排队提示。客户端继续轮询以获取秒杀结果；
7. 消息队列减库存、下订单、写入秒杀订单。

### 获取秒杀结果接口

- 接口地址：/bargains/result

- 请求方式：GET

- 请求参数：  

  | 请求字段 | 字段含义 | 是否必填 |
  | -------- | -------- | -------- |
  | goodsId  | 商品id   | 必填     |

- 返回响应：订单信息

#### 工作流程

从订单列表获取秒杀结果，返回给客户端订单信息。